{"version":3,"sources":["api/api.js","components/ToDoList/ToDo/ToDo.jsx","components/ToDoList/ToDoField/ToDoField.jsx","components/ToDoList/ModalEditMode/ModalEditMode.jsx","components/loader/loader.jsx","components/ToDoList/ToDoList.jsx","App.js","serviceWorker.js","index.js","components/ToDoList/ModalEditMode/ModalEditMode.module.css","components/ToDoList/ToDoField/ToDoField.module.css","components/ToDoList/ToDoList.module.css","assets/edit.svg","assets/trash.svg","assets/close.svg","components/loader/loader.module.css","assets/loader.svg","components/ToDoList/ToDo/ToDo.module.css"],"names":["getInitialState","axios","DeleteQuestion","showDeleteQuestion","removeToDo","id","className","style","deleteQuestion","onClick","autoFocus","ToDo","title","completed","onChange","index","openEditWindow","completedClasses","notCompletedText","titleInProgress","notCompletedBackground","completedText","titleCompleted","completedBackground","useState","draggableId","toString","provider","cn","toDo","background","draggableProps","dragHandleProps","ref","innerRef","onDoubleClick","onPointerLeave","customCheckbox","type","checked","for","edit","editButton","alt","src","editImg","detButton","delImg","text","ToDoField","addToDo","formikForm","useFormik","initialValues","toDoText","validationSchema","Yup","required","validateOnChange","validateOnBlur","onSubmit","values","resetForm","inputTextClass","errors","errorForInput","toDoTextField","handleSubmit","handleChange","name","value","placeholder","addToDoButton","error","ModalEditMode","toDoEditMode","completeEditToDo","closeEditMode","classForInput","input","inputError","modal","modalBody","formBlock","closeImg","Loader","loader","ToDoList","React","memo","toDosList","onChangeCompletion","onDragEnd","toDoBlock","logoName","droppableId","toDoList","droppableProps","length","map","key","noTasks","ToDoListContainer","changeToDosList","changeToDoEditMode","useEffect","then","response","data","reverse","taskId","toDoId","filter","ids","newId","Math","max","apply","Infinity","newToDos","unshift","result","destination","source","newToDoIds","Array","from","moveTask","splice","e","target","changeToDoTitle","forEach","newText","newToDoList","App","Boolean","window","location","hostname","match","ReactDOM","render","StrictMode","document","getElementById","navigator","serviceWorker","ready","registration","unregister","catch","console","message","module","exports"],"mappings":"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","file":"static/js/main.7eaddf0a.chunk.js","sourcesContent":["import * as axios from \"axios\";\r\n\r\n\r\n// Получение promise от сервера\r\nconst getInitialState = () => {\r\n    return axios.get(\"https://jsonplaceholder.typicode.com/todos?_limit=5\");\r\n}\r\n\r\nexport default getInitialState;","import React, {useState} from \"react\";\r\nimport cn from 'classnames';\r\nimport style from './ToDo.module.css';\r\nimport {Draggable} from \"react-beautiful-dnd\";\r\nimport PropTypes from 'prop-types';\r\nimport editImg from '../../../assets/edit.svg';\r\nimport delImg from '../../../assets/trash.svg';\r\n\r\n\r\n// Отрисовка одного дела\r\n// Drawing one to-do\r\nconst ToDo = ({title, id, completed, removeToDo, onChange, index, openEditWindow}) => {\r\n    let completedClasses = {\r\n        'text': style.notCompletedText,\r\n        'title': style.titleInProgress,\r\n        'background': style.notCompletedBackground\r\n    };\r\n    if (completed) {\r\n        completedClasses = {\r\n            'text': style.completedText,\r\n            'title': style.titleCompleted,\r\n            'background': style.completedBackground\r\n        };\r\n    }\r\n\r\n    // создание внутреннего состояния дела на открытие окна с подтверждением удаления\r\n    // creating an internal state of the case for opening a window with confirmation of deletion\r\n    let [deleteQuestion, showDeleteQuestion] = useState(false);\r\n\r\n    // задаем область перетаскиваемого объекта и в ней отрисовываем дело\r\n    // set the area of the dragged object and draw the to-do in it\r\n    return (\r\n\r\n        <Draggable draggableId={id.toString()} index={index}>\r\n            {(provider) => (\r\n                <div className={cn(style.toDo, completedClasses.background)}\r\n                     {...provider.draggableProps}\r\n                     {...provider.dragHandleProps}\r\n                     ref={provider.innerRef}\r\n                     onDoubleClick={openEditWindow}\r\n                     id={id}\r\n                     title={title}\r\n                     onPointerLeave={() => {\r\n                     }}>\r\n                    <input id={`toDoCheck${id}`} className={style.customCheckbox} type={'checkbox'} checked={completed} onChange={() => onChange(id)}/>\r\n                    <label for={`toDoCheck${id}`}/>\r\n                    <span className={completedClasses.title}\r\n                          id={id}>{!completed ? 'In progress...' : 'Completed!'}</span>\r\n                    {/*Если необходимо - показываем окно с подтверждением удаления*/}\r\n                    {/*If necessary, show a window with confirmation of deletion*/}\r\n                    {deleteQuestion ? <DeleteQuestion showDeleteQuestion={showDeleteQuestion}\r\n                                                      removeToDo={removeToDo}\r\n                                                      id={id}/> :\r\n                        <span className={cn(style.edit)}>\r\n                                <input id={id}\r\n                                       title={'Edit'}\r\n                                       className={cn(style.editButton)}\r\n                                       type={'image'}\r\n                                       alt={'Edit'}\r\n                                       onClick={openEditWindow}\r\n                                       src={editImg}/>\r\n                                <input className={cn(style.detButton)}\r\n                                       type={'image'}\r\n                                       src={delImg}\r\n                                       title={'Delete'}\r\n                                       alt={'Delete'}\r\n                                       onClick={() => showDeleteQuestion(true)}/>\r\n                     </span>}\r\n                    <div className={cn(completedClasses.text, style.title)} id={id} title={title}> {title} </div>\r\n                </div>\r\n            )\r\n            }\r\n        </Draggable>\r\n    );\r\n}\r\n\r\n// Компонент окна подтвержения удаления\r\n// Delete confirmation window component\r\nconst DeleteQuestion = ({showDeleteQuestion, removeToDo, id}) => {\r\n    return (<div className={style.deleteQuestion}>\r\n        Delete?&nbsp;\r\n        <button onClick={() => removeToDo(id)}>Yes</button>\r\n        <button autoFocus onClick={() => showDeleteQuestion(false)}>No</button>\r\n    </div>);\r\n}\r\n\r\n// Проверяем корректность типов пропсов\r\n// Checking the correctness of props types\r\nToDo.propTypes = {\r\n    title: PropTypes.string,\r\n    id: PropTypes.number,\r\n    completed: PropTypes.bool,\r\n    removeToDo: PropTypes.func,\r\n    onChange: PropTypes.func,\r\n    index: PropTypes.number,\r\n    openEditWindow: PropTypes.func\r\n}\r\n\r\nexport default ToDo;","import React from \"react\";\r\nimport {useFormik} from \"formik\";\r\nimport * as Yup from 'yup';\r\nimport cn from 'classnames';\r\nimport style from './ToDoField.module.css';\r\nimport PropTypes from 'prop-types';\r\n\r\n\r\n// Компонент поля с формой добавления нового дела\r\n// Field component with a form for adding a new to-do\r\n\r\nconst ToDoField = ({addToDo}) => {\r\n\r\n    // задание нового formik хука для контроля формы, с валидацией Yup-объектом\r\n    // setting a new formik hook for form control, with Yup object validation\r\n    const formikForm = useFormik({\r\n        initialValues: {\r\n            toDoText: ''\r\n        },\r\n        validationSchema: Yup.object({\r\n            toDoText: Yup.string()\r\n                .required('Your to-do must have text!')\r\n        }),\r\n        validateOnChange: false,\r\n        validateOnBlur: false,\r\n        onSubmit: values => {\r\n            addToDo(values.toDoText);\r\n            formikForm.resetForm();\r\n        }\r\n    });\r\n\r\n    // Задаем классы для поля ввода в зависимости от наличия ошибки\r\n    // Setting classes for the input field depending on the presence of an error\r\n    let inputTextClass = formikForm.errors.toDoText ? cn(style.errorForInput, style.toDoTextField) : style.toDoTextField;\r\n\r\n    // Отрисовываем форму, связывая ее с хуком formik для контроля формы\r\n    // Rendering the form by linking it to the formik hook for form control\r\n    return (\r\n        <form onSubmit={formikForm.handleSubmit}>\r\n            <div>\r\n                <textarea onChange={formikForm.handleChange}\r\n                       id={'toDoText'}\r\n                       name={'toDoText'}\r\n                       value={formikForm.values.toDoText}\r\n                       placeholder={'Your new to do'}\r\n                       className={inputTextClass}/>{' '}\r\n                <input type={'submit'} className={style.addToDoButton} value={''}/>\r\n                {formikForm.errors.toDoText &&\r\n                <div className={cn(style.error)}>{formikForm.errors.toDoText}</div>}\r\n            </div>\r\n        </form>\r\n    );\r\n\r\n}\r\n\r\n// Проверяем корректность типов пропсов\r\n// Checking the correctness of props types\r\nToDoField.propTypes = {\r\n    addToDo: PropTypes.func\r\n}\r\n\r\nexport default ToDoField;\r\n","import React from 'react';\r\nimport style from './ModalEditMode.module.css';\r\nimport cn from 'classnames';\r\nimport {useFormik} from \"formik\";\r\nimport * as Yup from \"yup\";\r\nimport PropTypes from 'prop-types';\r\nimport closeImg from '../../../assets/close.svg';\r\n\r\n\r\n// Компанент окна редактирования дела\r\n// To-do edit window component\r\n\r\nconst ModalEditMode = ({toDoEditMode, completeEditToDo, closeEditMode}) => {\r\n\r\n    // Создание хука formik для контроля формы, передавая в него начальные параметры, текст, из выбранным делом\r\n    // Creating a formik hook to control the form, passing in the initial parameters, text, from the selected to-do\r\n    let formikForm = useFormik({\r\n        initialValues: {\r\n            toDoText: toDoEditMode.title\r\n        },\r\n        validationSchema: Yup.object({\r\n            toDoText: Yup.string()\r\n                .required('Required!')\r\n        }),\r\n        onSubmit: values => {\r\n            completeEditToDo(toDoEditMode.id, values.toDoText);\r\n        }\r\n    });\r\n\r\n    // Задаем классы для поля ввода в зависимости от наличия ошибки\r\n    // Setting classes for the input field depending on the presence of an error\r\n    let classForInput = style.input;\r\n    if (formikForm.errors.toDoText)\r\n        classForInput = cn(classForInput, style.inputError);\r\n\r\n    return (\r\n        <>\r\n            {/*Если было произведено двойное нажатие на \"серой\" области, подложке, окна - то произайдет закрытие редактирования без сохранения изменений*/}\r\n            {/*If you double-clicked on the \"gray\" area, background, window - then the editing will be closed without saving changes*/}\r\n            <div className={cn(style.modal)} id={'background'} onDoubleClick={closeEditMode}>\r\n                <div className={cn(style.modalBody)}>\r\n                    <form onSubmit={formikForm.handleSubmit} className={style.formBlock}>\r\n                        <textarea\r\n                            className={classForInput}\r\n                            onChange={formikForm.handleChange}\r\n                            id={'toDoText'}\r\n                            name={'toDoText'}\r\n                            value={formikForm.values.toDoText}\r\n                            placeholder={'Your to do'}\r\n                            autoFocus/>\r\n                        <button className={style.editButton} type={'submit'}>Edit to do</button>\r\n                        {/*Если было произведено двойное нажатие на \"крестике\" - то произайдет закрытие редактирования без сохранения изменений*/}\r\n                        {/*If you double-clicked on the \"cross\", then the editing will be closed without saving the changes*/}\r\n                        <input className={cn(style.closeImg)} type={'image'} alt={'Close'} src={closeImg} onClick={closeEditMode} id={'background'}/>\r\n                        {formikForm.errors.toDoText &&\r\n                        <div className={cn(style.error)}>{formikForm.errors.toDoText}</div>}\r\n                    </form>\r\n                </div>\r\n            </div>\r\n        </>\r\n    );\r\n}\r\n\r\n// Проверяем корректность типов пропсов\r\n// Checking the correctness of props types\r\nModalEditMode.propTypes = {\r\n    toDoEditMode: PropTypes.object,\r\n    completeEditToDo: PropTypes.func,\r\n    closeEditMode: PropTypes.func\r\n}\r\n\r\nexport default ModalEditMode;\r\n","import React from \"react\";\r\nimport style from \"./loader.module.css\";\r\nimport loader from '../../assets/loader.svg'\r\n\r\n\r\n// Компонент, отображающий loader и использующийся для демонстрации прогресса-ожидания\r\n// The component that displays the loader and is used to display pending execution.\r\nconst Loader = () => {\r\n    return (\r\n        <div>\r\n            <img  className={style.loader} src={loader} alt={'Loading...'}/>\r\n        </div>\r\n    );\r\n}\r\n\r\nexport default Loader;","import React, {useEffect, useState} from 'react';\r\nimport style from './ToDoList.module.css'\r\nimport getInitialState from \"../../api/api\";\r\nimport ToDo from \"./ToDo/ToDo\";\r\nimport ToDoField from \"./ToDoField/ToDoField\";\r\nimport {DragDropContext, Droppable} from \"react-beautiful-dnd\";\r\nimport cn from 'classnames';\r\nimport ModalEditMode from \"./ModalEditMode/ModalEditMode\";\r\nimport Loader from \"../loader/loader\";\r\nimport PropTypes from 'prop-types';\r\n\r\n\r\n// Презентационная компанента списка дел\r\n// To-do list presentation component\r\n\r\nconst ToDoList = React.memo(({\r\n                                 toDosList, onChangeCompletion, removeToDo, addToDo,\r\n                                 onDragEnd, openEditWindow, toDoEditMode, completeEditToDo, closeEditMode\r\n                             }) => {\r\n\r\n\r\n    return (\r\n        <>\r\n            <div className={style.toDoBlock}>\r\n                <h1 className={style.logoName}>ToDo List</h1>\r\n                <ToDoField addToDo={addToDo}/>\r\n                {/* Задаем контекст для области перетягивания */}\r\n                {/* Setting the context for the drag area */}\r\n                <DragDropContext\r\n                    onDragEnd={onDragEnd}>\r\n                    {/*Задаем столбец, в котором осуществляется перетягивание*/}\r\n                    {/*Set the column to be dragged*/}\r\n                    <Droppable droppableId={'list'}>\r\n                        {(provider) => (\r\n                                <div className={cn(style.toDoList)}\r\n                                     {...provider.droppableProps}\r\n                                     ref={provider.innerRef}\r\n                                >\r\n                                    {/*Пробегаемся по массиву списка дел и каждое отрисовываем*/}\r\n                                    {/*Loop through an array of to-do lists and draw each*/}\r\n                                    {toDosList.length !== 0 ? toDosList.map((toDo, index) => {\r\n                                        return <ToDo key={toDo.id}\r\n                                                  id={toDo.id}\r\n                                                  title={toDo.title}\r\n                                                  completed={toDo.completed}\r\n                                                  onChange={onChangeCompletion}\r\n                                                  removeToDo={removeToDo}\r\n                                                  index={index}\r\n                                                  openEditWindow={openEditWindow}/>\r\n                                    }) : <span className={style.noTasks}>No tasks!</span>}\r\n                                    {/*Передаем задний фон самого объекта области перетягивания*/}\r\n                                    {/*Passing the background of the object itself to the drag area*/}\r\n                                    {provider.placeholder}\r\n                                </div>\r\n                        )\r\n                        }\r\n                    </Droppable>\r\n                </DragDropContext>\r\n            </div>\r\n            {/*Если включен режим редактирования - отрисовать компонент окна редактирования*/}\r\n            {/*If editing mode is enabled, draw the editing window component*/}\r\n            {toDoEditMode.edit && <ModalEditMode toDoEditMode={toDoEditMode}\r\n                                                 completeEditToDo={completeEditToDo}\r\n                                                 closeEditMode={closeEditMode}/>}\r\n        </>\r\n    );\r\n})\r\n\r\n// Проверяем корректность типов пропсов\r\n// Checking the correctness of props types\r\nToDoList.propTypes = {\r\n    toDosList: PropTypes.array,\r\n    onChangeCompletion: PropTypes.func,\r\n    removeToDo: PropTypes.func,\r\n    addToDo: PropTypes.func,\r\n    onDragEnd: PropTypes.func,\r\n    openEditWindow: PropTypes.func,\r\n    toDoEditMode: PropTypes.object,\r\n    completeEditToDo: PropTypes.func,\r\n    closeEditMode: PropTypes.func\r\n}\r\n\r\n// Контейнерная компонента для всего списка дел, где совершаются ассинхронные операции, хранится State и находятся обработчики событий, изменяющие State\r\n// The container component for the entire to-do list, where asynchronous operations are performed, State is stored and event handlers that change State are located\r\n\r\nconst ToDoListContainer = () => {\r\n\r\n\r\n    // Задание первоначального State - пустой массив\r\n    // Setting the initial State to an empty array\r\n    let [toDosList, changeToDosList] = useState(false);\r\n\r\n    // Состояние для окна редактирования, включает: включен/выключен режим редактирования, id редактируемого поля, изначальный title поля\r\n    // State for the edit window, includes: enabled / disabled edit mode, id of the edited field, initial title of the field\r\n    let [toDoEditMode, changeToDoEditMode] = useState({\r\n        'edit': false,\r\n        'id': null,\r\n        'title': null\r\n    });\r\n\r\n    // Запрос на сервер и обработка ответа с обновлением State\r\n    // Server request and response processing with State update\r\n    useEffect(() => {\r\n        getInitialState().then(response => {\r\n            changeToDosList(response.data.reverse());\r\n        })\r\n    }, []);\r\n\r\n    // Обработка изменения статуса выполнения дела, принимает id дела, статус которого необходимо поменять\r\n    // Processing a change in the status of the to-do, accepts the id of the to-do, the status of which needs to be changed\r\n    const onChangeCompletion = (taskId) => {\r\n        changeToDosList(toDosList.map(toDo => {\r\n            if (toDo.id === taskId) {\r\n                toDo.completed = !toDo.completed;\r\n            }\r\n            return toDo;\r\n        }));\r\n    }\r\n\r\n    // Удаление дела. Принимает id дела, которое удаляется из общего списка дел\r\n    // Deleting to-do. Accepts the id of the case, which is removed from the general to-do list\r\n    const removeToDo = (toDoId) => {\r\n        changeToDosList(toDosList.filter(toDo => toDo.id !== toDoId));\r\n    }\r\n\r\n    // Добавление нового дела. Принимает текст нового дела и создает объект нового дела, добавляя его в начало списка\r\n    // Adding a new to-do. Accepts the text of a new to-do and creates a new to-do object, adding it to the beginning of the list\r\n    const addToDo = (toDoText) => {\r\n        let ids = toDosList.map(toDo => toDo.id);\r\n        let newId = Math.max.apply(null, ids) + 1;\r\n        if (newId === -Infinity) newId = 1;\r\n        let newToDos = [...toDosList];\r\n        newToDos.unshift({\r\n            'userId': 1,\r\n            'id': newId,\r\n            'title': toDoText,\r\n            'completed': false\r\n        });\r\n        changeToDosList(newToDos);\r\n    }\r\n\r\n\r\n    // Обработка события по завершению перетягивания дела\r\n    // Handling an event upon completion of a to-do drag\r\n    const onDragEnd = (result) => {\r\n        // Из пришедшего объекта получаем объекты конечного места назначения и начальной позиции\r\n        // From the arrived object, we get objects of the final destination and starting position\r\n        const {destination, source} = result;\r\n\r\n        // Проверяем, было ли перемещение вообще, изменилось ли местоположение дела\r\n        // Check if there was a move at all, if the location of the case changed\r\n        if (!destination || (destination.droppableId === source.droppableId && destination.index === source.index)) {\r\n            return;\r\n        }\r\n\r\n        //получаем массив всех дел\r\n        //get an array of all to-dos\r\n        const newToDoIds = Array.from(toDosList);\r\n        //копируем переносимый элемент\r\n        //copy the transferred element\r\n        const moveTask = {...newToDoIds[source.index]};\r\n        //удаляем перенесенное дело из массива\r\n        //remove the transferred to-do from the array\r\n        newToDoIds.splice(source.index, 1);\r\n        //вставляем дело на новое положение\r\n        //insert the to-do into a new position\r\n        newToDoIds.splice(destination.index, 0, moveTask);\r\n\r\n        //обновляем state\r\n        //update state\r\n        changeToDosList(newToDoIds);\r\n\r\n    }\r\n\r\n\r\n    // Появление режима редактирования для инициировавшего его дела\r\n    // The appearance of the editing mode for the initiator of the to-do\r\n    const openEditWindow = (e) => {\r\n        if (e.target.type === 'checkbox')\r\n            return;\r\n        let changeToDoTitle = null;\r\n        toDosList.forEach(toDo => {\r\n            if (toDo.id.toString() === e.target.id.toString()) {\r\n                changeToDoTitle = toDo.title;\r\n                return;\r\n            }\r\n        });\r\n        changeToDoEditMode({\r\n            'edit': true,\r\n            'id': e.target.id,\r\n            'title': changeToDoTitle\r\n        });\r\n    }\r\n\r\n    // Сохраниение отредактироованного дела\r\n    // Saving edited to-do\r\n    const completeEditToDo = (id, newText) => {\r\n        const newToDoList = toDosList.map(toDo => {\r\n            if (toDo.id.toString() === id) toDo.title = newText;\r\n            return toDo;\r\n        });\r\n        changeToDosList(newToDoList);\r\n        changeToDoEditMode({\r\n            'edit': false,\r\n            'id': null,\r\n            'title': null\r\n        });\r\n    }\r\n\r\n    // Закрытие окна редактирования без сохранения изменений\r\n    // Closing the editing window without saving changes\r\n    const closeEditMode = (e) => {\r\n        if (e.target.id !== 'background') {\r\n            return;\r\n        }\r\n        changeToDoEditMode({\r\n            'edit': false,\r\n            'id': null,\r\n            'title': null\r\n        });\r\n    }\r\n\r\n\r\n    // Отрисовка списка дел, если он есть. Иначе отрисовывается загрузчик\r\n    // Rendering the to-do list, if any. Otherwise, the loader is rendered\r\n    return (\r\n        <>\r\n            {!toDosList && <Loader />}\r\n            {toDosList && <ToDoList toDosList={toDosList}\r\n                                   onChangeCompletion={onChangeCompletion}\r\n                                   removeToDo={removeToDo}\r\n                                   addToDo={addToDo}\r\n                                   onDragEnd={onDragEnd}\r\n                                   openEditWindow={openEditWindow}\r\n                                   toDoEditMode={toDoEditMode}\r\n                                   completeEditToDo={completeEditToDo}\r\n                                   closeEditMode={closeEditMode}/>}\r\n        </>\r\n    );\r\n}\r\n\r\nexport default ToDoListContainer;","import React from 'react';\nimport ToDoListContainer from \"./components/ToDoList/ToDoList\";\n\n\n//Базовая отрисовка корня приложения\n//Basic rendering of the application root\n\nconst App = () => {\n  return (\n      <ToDoListContainer/>\n  );\n}\n\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' },\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready\n      .then(registration => {\n        registration.unregister();\n      })\n      .catch(error => {\n        console.error(error.message);\n      });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n","// extracted by mini-css-extract-plugin\nmodule.exports = {\"modal\":\"ModalEditMode_modal__1L_dm\",\"modalBody\":\"ModalEditMode_modalBody__2RfV-\",\"error\":\"ModalEditMode_error__3yLH7\",\"formBlock\":\"ModalEditMode_formBlock__3Wtfq\",\"input\":\"ModalEditMode_input__2cmCs\",\"inputError\":\"ModalEditMode_inputError__1hXWc\",\"closeImg\":\"ModalEditMode_closeImg__3fvKy\",\"editButton\":\"ModalEditMode_editButton__3ZhEF\"};","// extracted by mini-css-extract-plugin\nmodule.exports = {\"error\":\"ToDoField_error__2qULJ\",\"errorForInput\":\"ToDoField_errorForInput__2rFWl\",\"addToDoButton\":\"ToDoField_addToDoButton__1FA5V\",\"toDoTextField\":\"ToDoField_toDoTextField__2TV7r\"};","// extracted by mini-css-extract-plugin\nmodule.exports = {\"toDoBlock\":\"ToDoList_toDoBlock__1F8vA\",\"logoName\":\"ToDoList_logoName__3TycJ\",\"toDoList\":\"ToDoList_toDoList__38NNc\",\"noTasks\":\"ToDoList_noTasks__3Z-vc\"};","module.exports = __webpack_public_path__ + \"static/media/edit.5c12591d.svg\";","module.exports = __webpack_public_path__ + \"static/media/trash.665926e2.svg\";","module.exports = __webpack_public_path__ + \"static/media/close.20ced97c.svg\";","// extracted by mini-css-extract-plugin\nmodule.exports = {\"loader\":\"loader_loader__3ob6H\"};","module.exports = __webpack_public_path__ + \"static/media/loader.73cfd7f8.svg\";","// extracted by mini-css-extract-plugin\nmodule.exports = {\"completedBackground\":\"ToDo_completedBackground__1UXK7\",\"notCompletedBackground\":\"ToDo_notCompletedBackground__XzVhG\",\"completedText\":\"ToDo_completedText__2cRpw\",\"notCompletedText\":\"ToDo_notCompletedText__1kRvc\",\"toDo\":\"ToDo_toDo__2B14_\",\"edit\":\"ToDo_edit__2J7hJ\",\"editButton\":\"ToDo_editButton__37Z0R\",\"detButton\":\"ToDo_detButton__2V3OR\",\"title\":\"ToDo_title__1ReA-\",\"titleCompleted\":\"ToDo_titleCompleted__20cda\",\"titleInProgress\":\"ToDo_titleInProgress__hSc5w\",\"deleteQuestion\":\"ToDo_deleteQuestion__2pP3-\",\"customCheckbox\":\"ToDo_customCheckbox__TMmno\"};"],"sourceRoot":""}